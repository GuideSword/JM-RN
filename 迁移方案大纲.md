# JM-NcatBot 迁移至 React Native Expo 实现方案大纲

## 项目分析

### 1.1 当前项目架构分析

#### 技术栈
- **前端/交互层**: Napcat + NcatBot (QQ 机器人框架)
- **核心下载库**: jmcomic (JMComic-Crawler-Python)
- **图片处理**: img2pdf (图片转 PDF)
- **配置文件**: config.yml (jmcomic 配置)

#### 工作流程
1. 用户通过 QQ 发送命令 `/jm <album_id>`
2. QQ 机器人接收消息，解析 album_id
3. Python 调用 `jmcomic.JmOption.from_file(config).download_album([album_id])`
4. 图片下载到 `stock/` 目录
5. 通过 `img2pdf` 插件自动转换为 PDF 存储在 `pdf/` 目录
6. 通过 QQ 发送 PDF 文件给用户

#### 核心依赖关系
- **与 QQ 耦合的部分**: 
  - 消息接收 (`@bot.group_event()`, `@bot.private_event()`)
  - 文件发送 (`msg.reply()`, `bot.api.post_private_msg()`)
  - 配置初始化 (`config.set_bot_uin()`, `config.set_ws_uri()`)

- **独立的核心功能**:
  - `jmcomic` 库本身完全独立，不依赖 QQ
  - 图片下载逻辑 (`loadConfig.download_album()`)
  - 图片转 PDF (`img2pdf` 插件)

### 1.2 可行性评估

#### ✅ 方案可行性：完全可行

**理由**：
1. `jmcomic` 库是独立的 Python 库，与 QQ 无关
2. 下载功能的核心逻辑在 `main.py` 中仅占少数几行（第 53、77 行）
3. React Native Expo 可以通过多种方式调用 Python 后端：
   - RESTful API
   - GraphQL API
   - 本地 Python 脚本调用（通过 expo-file-system 和 expo-task-manager）

---

## 实现方案

### 方案A：React Native Expo + Python 后端 API（推荐）

#### 架构设计
```
React Native Expo App (前端)
    ↓ HTTP/HTTPS
FastAPI/Flask Backend (Python API)
    ↓
jmcomic 库 + img2pdf
    ↓
本地存储 / 云存储
```

#### 优势
- 清晰的前后端分离
- 易于维护和扩展
- 支持多平台（iOS、Android、Web）
- 可以部署到服务器，支持多设备访问
- 可以实现任务队列，支持批量下载

#### 劣势
- 需要维护后端服务
- 需要网络连接（本地部署时可避免）

### 方案B：React Native Expo 直接调用本地 Python 脚本

#### 架构设计
```
React Native Expo App
    ↓ (通过 expo-file-system + expo-task-manager)
本地 Python 脚本 (subprocess)
    ↓
jmcomic 库 + img2pdf
```

#### 优势
- 不需要后端服务器
- 完全本地化运行
- 数据隐私性更好

#### 劣势
- 移动端需要安装 Python 环境（较复杂）
- 跨平台兼容性较差
- 性能可能不如原生实现

---

## 详细实现步骤

### 第一部分：Python 后端 API 开发

#### 1.1 创建独立的后端服务

**文件结构**：
```
JM-Download-API/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI 主应用
│   ├── models.py            # 数据模型
│   ├── download_service.py  # 下载服务封装
│   └── config.py            # 配置管理
├── config.yml               # jmcomic 配置（从原项目复制）
├── requirements.txt
└── README.md
```

#### 1.2 核心 API 接口设计

**端点列表**：
- `POST /api/v1/download/album`
  - 请求体: `{ "album_id": "350234" }`
  - 响应: `{ "task_id": "xxx", "status": "started" }`

- `GET /api/v1/download/status/{task_id}`
  - 响应: `{ "status": "downloading|completed|failed", "progress": 0.5, "message": "..." }`

- `GET /api/v1/download/result/{album_id}`
  - 返回 PDF 文件流

- `GET /api/v1/download/list`
  - 返回已下载的专辑列表

#### 1.3 下载服务封装

**核心代码结构**：
```python
# download_service.py
from jmcomic import JmOption
from typing import Dict, Optional
import asyncio

class DownloadService:
    def __init__(self, config_path: str = "config.yml"):
        self.option = JmOption.from_file(config_path)
        self.tasks: Dict[str, Dict] = {}
    
    async def download_album(self, album_id: str) -> str:
        # 异步下载逻辑
        # 更新任务状态
        pass
    
    def get_status(self, task_id: str) -> Dict:
        # 返回任务状态
        pass
```

#### 1.4 任务队列实现

- 使用 Celery + Redis（生产环境）
- 或使用简单的 asyncio 任务队列（开发/小规模使用）

---

### 第二部分：React Native Expo 前端开发

#### 2.1 项目初始化

```bash
npx create-expo-app JM-Download-Client
cd JM-Download-Client
```

#### 2.2 核心依赖安装

```json
{
  "expo": "~49.0.0",
  "react-native": "0.72.6",
  "axios": "^1.5.0",
  "expo-file-system": "~15.4.0",
  "expo-document-picker": "~11.8.0",
  "expo-sharing": "~11.5.0",
  "expo-notifications": "~0.20.1",
  "@react-navigation/native": "^6.1.7",
  "@react-navigation/stack": "^6.3.17",
  "react-native-paper": "^5.10.0",
  "react-native-pdf": "^6.7.2"
}
```

#### 2.3 功能模块设计

**主要界面**：
1. **首页/搜索页**
   - 输入 album_id
   - 搜索功能（可选）
   - 下载历史列表

2. **下载管理页**
   - 进行中的下载任务
   - 下载进度显示
   - 取消下载功能

3. **内容浏览页**
   - 已下载的专辑列表
   - 图片浏览（支持 PDF 或图片流）
   - 分享功能

4. **设置页**
   - API 地址配置
   - 存储位置设置
   - 缓存管理

#### 2.4 API 服务封装

```typescript
// services/api.ts
import axios from 'axios';

const API_BASE_URL = 'http://your-backend-url/api/v1';

export const downloadService = {
  startDownload: async (albumId: string) => {
    const response = await axios.post(`${API_BASE_URL}/download/album`, {
      album_id: albumId
    });
    return response.data;
  },
  
  getStatus: async (taskId: string) => {
    const response = await axios.get(`${API_BASE_URL}/download/status/${taskId}`);
    return response.data;
  },
  
  downloadPDF: async (albumId: string) => {
    // 下载 PDF 文件
  }
};
```

#### 2.5 本地存储管理

- 使用 `expo-file-system` 管理下载的文件
- 使用 `AsyncStorage` 或 `expo-secure-store` 存储配置和元数据

---

### 第三部分：关键技术实现细节

#### 3.1 图片下载流程优化

**当前流程**：
1. 接收 album_id
2. 调用 `download_album()`
3. 等待下载完成
4. 转换为 PDF

**优化后的异步流程**：
1. 接收 album_id，立即返回 task_id
2. 后台异步下载，定期更新进度
3. 下载完成后通知前端
4. 前端可选择下载 PDF 或直接浏览图片

#### 3.2 进度反馈机制

**实现方式**：
- WebSocket 实时推送（推荐）
- 或前端轮询 `/status` 接口

**进度数据结构**：
```json
{
  "task_id": "xxx",
  "album_id": "350234",
  "status": "downloading",
  "progress": 0.65,
  "current_image": 20,
  "total_images": 34,
  "message": "正在下载第 20/34 张图片"
}
```

#### 3.3 图片浏览方案

**选项 1：PDF 阅读器**
- 使用 `react-native-pdf` 组件
- 优点：原项目已生成 PDF
- 缺点：PDF 文件较大，加载慢

**选项 2：图片流浏览**
- 直接读取 `stock/` 目录中的图片
- 使用 `react-native-image-viewing` 或 `expo-image`
- 优点：加载快，体验好
- 缺点：需要处理图片解码（jmcomic 已支持）

#### 3.4 缓存和存储管理

**存储策略**：
- 已下载的图片保留在 `stock/` 目录
- PDF 可选择生成或按需生成
- 实现清理功能，支持删除旧内容

---

### 第四部分：部署和运维

#### 4.1 后端部署

**选项 A：本地部署**
- 运行在用户本地机器
- React Native App 通过本地 IP 访问
- 适合个人使用

**选项 B：云服务器部署**
- 部署到 VPS 或云服务器
- 支持多设备访问
- 需要 HTTPS 和认证

#### 4.2 移动端打包

**Android**:
```bash
eas build --platform android
```

**iOS**:
```bash
eas build --platform ios
```

#### 4.3 配置管理

**后端配置**：
- 环境变量管理敏感信息
- `config.yml` 保持与原项目兼容

**前端配置**：
- 首次启动时配置 API 地址
- 支持切换本地/云端后端

---

## 技术难点和解决方案

### 难点 1：jmcomic 库的图片解码

**问题**：JM 网站的原图是混淆过的，需要解码

**解决方案**：
- `jmcomic` 已内置解码功能（`config.yml` 中 `decode: true`）
- 前端直接使用解码后的图片即可

### 难点 2：大量图片的下载和存储

**问题**：一个专辑可能包含几十到上百张图片

**解决方案**：
- 实现断点续传
- 支持批量下载队列
- 压缩存储（可选）

### 难点 3：跨平台文件路径

**问题**：不同平台的文件系统路径不同

**解决方案**：
- 使用 `expo-file-system` 的路径抽象
- 统一使用相对路径或文档目录

### 难点 4：网络请求的认证和代理

**问题**：可能需要代理访问 JM 网站

**解决方案**：
- 在 Python 后端配置代理（`jmcomic` 支持）
- 前端无需关心网络细节

---

## 项目迁移检查清单

### 后端迁移
- [ ] 创建 FastAPI/Flask 项目结构
- [ ] 封装 `jmcomic` 下载逻辑
- [ ] 实现异步任务队列
- [ ] 实现进度跟踪机制
- [ ] 实现文件下载 API
- [ ] 添加错误处理和日志
- [ ] 编写 API 文档
- [ ] 配置 CORS 支持移动端访问

### 前端迁移
- [ ] 初始化 Expo 项目
- [ ] 安装必要的依赖
- [ ] 实现 API 服务封装
- [ ] 实现下载管理界面
- [ ] 实现图片浏览界面
- [ ] 实现本地存储管理
- [ ] 添加错误处理和用户反馈
- [ ] 优化用户体验（加载状态、动画等）
- [ ] 测试 Android/iOS 兼容性

### 配置和部署
- [ ] 复制并验证 `config.yml` 配置
- [ ] 配置后端部署环境
- [ ] 配置前端打包环境
- [ ] 编写部署文档
- [ ] 编写用户使用文档

---

## 扩展功能建议

### 短期扩展
1. **搜索功能**
   - 集成 JM 网站搜索 API（如果有）
   - 或通过爬虫实现搜索

2. **收藏功能**
   - 本地收藏夹
   - 同步到云端（可选）

3. **分享功能**
   - 分享专辑链接
   - 导出图片到相册

### 长期扩展
1. **用户系统**
   - 用户注册登录
   - 下载历史云端同步

2. **推荐系统**
   - 基于下载历史的推荐

3. **社区功能**
   - 用户评论和评分

---

## 风险评估

### 技术风险
- **风险**：`jmcomic` 库未来可能不兼容
  - **缓解**：保持关注库的更新，考虑 fork 维护

- **风险**：JM 网站结构变化导致下载失败
  - **缓解**：实现错误重试机制，及时更新库版本

### 法律风险
- **风险**：下载受版权保护的内容
  - **说明**：本项目仅作为技术研究，用户需自行承担法律责任

---

## 时间估算

### 开发阶段
- **后端 API 开发**：3-5 天
- **前端基础功能**：5-7 天
- **图片浏览功能**：2-3 天
- **测试和优化**：2-3 天

**总计**：约 12-18 个工作日

---

## 总结

### 方案可行性结论
✅ **完全可行** - `jmcomic` 库完全独立，可以轻松从 QQ 机器人架构迁移到 React Native Expo + Python 后端架构。

### 推荐架构
**React Native Expo 前端 + FastAPI Python 后端 + jmcomic 核心库**

这种架构具有：
- 良好的可维护性和可扩展性
- 清晰的职责分离
- 跨平台支持
- 便于未来功能扩展

### 下一步行动
1. 先搭建 Python 后端 API，验证核心下载功能
2. 开发 React Native Expo 前端基础界面
3. 实现前后端联调
4. 完善用户体验和错误处理
5. 部署和测试

---

## 参考资源

- [JMComic-Crawler-Python GitHub](https://github.com/hect0x7/JMComic-Crawler-Python)
- [FastAPI 文档](https://fastapi.tiangolo.com/)
- [React Native Expo 文档](https://docs.expo.dev/)
- [Expo File System](https://docs.expo.dev/versions/latest/sdk/filesystem/)
- [Expo Document Picker](https://docs.expo.dev/versions/latest/sdk/document-picker/)

---

**文档版本**: v1.0  
**创建日期**: 2025-04-06  
**最后更新**: 2025-04-06

